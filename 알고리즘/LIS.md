## LIS (최장 증가 부분 수열)

어떤 임의의 수열이 주어질 때, 이 수열에서 몇 개의 수들을 제거해서 부분수열을 만들 수 있다. 이때 만들어진 부분수열 중 오름차순으로 정렬된 가장 긴 수열을 최장 증가 부분 수열이라 한다.

LIS를 구하기 위해서는 다음과 같은 과정을 거친다.

수열 `a` 가 있다고 가정하였을때,

`dp[i]` 는 `i`번째 인덱스까지 `a[i]` 값이 가지는 최장 증가 부분 수열의 길이다.

+ 즉, `[3,2,1,2,5]` 라는 수열이 있을 때, dp는 `[1,1,1,2,3]` 가 된다.

+ `i = 2` 일때 `a = [3,2]` 이며 가장 긴 부분증가 수열의 길이는 1이다.
+ `i` 이전에 `a[i]` 보다 작은 모든 값중 가장 큰 값, `max(a[:i])` 를 찾고 그 값을 `a[j]` 라 한다면
+ `dp[i] = dp[j] + 1` 이다.
+ 왜냐하면 `a[i-n] > a[i]` 는 증가하지 않기 때문에 의미가 없다.
+ `a[i-n] < a[i]` 이어야 수열이 증가한다.

`dp`를 구하는 식

```python
for i in range(1,n+1):
    k = []
    for j in range(0,i):
        if a[i] > a[j]:
            k.append(dp[j])
    dp[i] = max(k) + 1
```

`j < i` 이다

`a[j] < a[i]` 인 모든 `j` 에 대하여 `dp[j]` 를 모아둔 리스트를 `k` 라 할 때,

`dp[i] = max(k) + 1` 이다.



### 예

`10, 3, 2, 3 ,2, 5, 7` 과 같은 수열이 존재한다고 하자.

`dp[0] = 0, a[0] = 0` 라고 가정하자.

`i = 1` 일때 값은 10이며, `a[0]` 뒤에 올 수 있기 때문에 `dp[1] = dp[0] + 1 = 1` 이된다.

`i = 2` 일때 값은 3이며, `a[0]` 뒤에 올 수 있기 때문에 `dp[2] = dp[0] + 1 = 1` 이된다.

`i = 3` 일때 값은 2이며, `a[0]` 뒤에 올 수 있기 때문에 `dp[3] = dp[0] + 1 = 1` 이된다.

`i = 4` 일때 값은 3이며, `a[3]` 뒤에 올 수 있기 때문에 `dp[4] = dp[3] + 1 = 2` 이된다.

+ 이때 `a[4]` 보다 작은 `a[i]` 값만을 고려한다.

`i = 5` 일때 값은 2이며, `a[0]` 뒤에 올 수 있기 때문에 `dp[5] = dp[0] + 1 = 1` 이된다.

`i = 6` 일때 값은 5이며, `a[4]` 뒤에 올 수 있기 때문에 `dp[6] = dp[4] + 1 = 3` 이된다.

`i = 7` 일때 값은 7이며, `a[6]` 뒤에 올 수 있기 때문에 `dp[7] = dp[6] + 1 = 4` 이된다.
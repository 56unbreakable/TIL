# 데이터 모델링의 이해

## 데이터 모델링

### 데이터 모델링의 이해

#### 데이터 모델링

1. 현실 세계를 데이터 베이스로 표현하기 위해 추상화
2. 고객의 업무 프로세스를 이해해야함
3. 모델링 표기법을 사용해 모델링
4. 복잡하지 않게 모델링
5. 분석, 설계하면서 더 상세해짐
6. 비즈니스 프로세스를 이해하고  규칙을 정의하여 데이터모델로 표현

#### 데이터 모델링의 특징

추상화 : 공통적인 특징을 찾고 간략하게 표현

단순화 : 누구나 이해할 수 있게 표현

명확함 : 의미적 해석이 모호하지 않고 명확하게 해석되어야함

#### 데이터 모델링 단계

1. 개념적 모델링

   복잡하게 표현하지 않고 중요한 부분을 위주로 모델링, 기술적인 용어는 가급적 사용 안함.

   엔터티와 속성 도출, 개념적 ERD 작성

   추상화 수준이 가장 높다.

2. 논리적 모델링

   개념적 모델링을 논리적 모델링으로 변환, 식별자 도출, 릴레이션 정의, 정규화수행

   재사용성을 높인다

3. 물리적 모델링

   실제로 데이터베이스 구축. 테이블, 인덱스, 함수 등 생성

   성능, 보안, 가용성 등을 고려하여 데이터베이스 구축

+ 데이터 모델링 관점
  1. 데이터 : 비즈니스 프로세스에서 사용되는 데이터를 의미
  2. 프로세스 : 비즈니스 프로세스에서 수행하는 작업을 의미
  3. 데이터와 프로세스 : 프로세스와 데이터 간의 관계를 의미

#### ERD

+ ERD 작성절차

  1. 엔터티를 도출하고 그린다
  2. 엔터티를 배치한다
  3. 엔터티 간의 관계를 설정한다
  4. 관계명을 서술한다. 엔터티 간의 어떤 행위나 존재가 있는지 표현한다.
  5. 관계 참여도를 표현한다. 관계참여도는 한 개의 엔터티와 다른 엔터티 간의 참여하는 관계 수를 의미한다.
  6. 관계의 필수여부를 표현한다.

+ 고려사항

  중요한 엔터티를 가급적 왼쪽 상단에 배치한다.

  ERD는 이해가 쉬워야하고 복잡하지 않아야한다.

#### 데이터 모델링 고려사항

1. 데이터 모델의 독립성 : 정규화를 통해 데이터 중복 제가
2. 고객 요구사항의 표현 
3. 데이터 품질 확보



### 3층 스키마

#### 3층 스키마

사용자, 설계자, 개발자가 데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 이들간의 관꼐를 정의한 ANSI표준

3층 스키마는 데이터베이스의 독립성을 확보하기 위한 방법이다. 독립성을 확보하면 데이터 복잡도 감소, 데이터 중복 제거, 사용자 요구사항 변경에 따른 대응력 향상, 관리 및 유지보수 비용 절감

3단계 계층으로 분리, 각 계층을 뷰`View` 라고 함.

+ 논리적 독립성 : 개념 스키마가 변경되더라도 외부 스키마가 영향을 받지 않는 것
+ 물리적 독립성 : 내부 스키마가 변경되더라도 개념 스키마가 영향을 받지 않는 것

#### 3층 스키마 구조

외부단계 -> 개념단계 -> 내부단계

+ 외부 스키마 : 사용자 관점, 응용 프로그램이 접근하는 데이터베이스 정의, 사용자 관점에서 업무상 관련이 있는 데이터 접근.
+ 개념 스키마 : 설계자 관점, 사용자 전체 집단의 데이터베이스 구조. 전체 데이터베이스 내의 규칙과 구조를 표현, 통합 데이터베이스구조
+ 내부 스키마 : 개발자 관점, 데이터베이스의 물리적 저장 구조. 데이터저장구조, 레코드구조, 필드정의, 인덱스 등등의미.



### 엔터티

#### 엔터티

업무에서 관리해야 하는 데이터집합을 의미. 저장되고 관리되어야 하는 데이터.

엔터티는 개념, 사건, 장소등의 명사.

#### 엔터티 도출

고객의 비즈니스 프로세스에서 관리되어야 하는 정보를 추출.

#### 엔터티 특징

1. 식별자 : 엔터티는 유일한 식별자가 있어야함
2. 인스턴스 집합 : 2개 이상의 인스턴스가 있어야함
3. 속성 : 반드시 속성을 가지고 있음
4. 관계 : 다른 엔터티와 최소 한 개 이상의 관계를 가져야함
5. 업무 : 업무에서 관리되어야 하는 집합.

+ 릴레이션과 테이블, 인스턴스

  릴레이션과 테이블은 같은의미, 릴레이션에 기본키 및 제약조건을 설정하면 테이블.

  단, 릴레이션쉽은 릴레이션간의 관계를 의미

  인스턴스는 릴레이션이 가질 수 있는 값을 의미.

#### 엔터티 종류

+ 유형과 무형에 따른 엔터티 종류
  1. 유형 엔터티 : 업무에서 도출되어 지속적으로 사용되는 엔터티
  2. 개념 엔터티 : 물리적 형태가 없음. 개념적으로 사용되는 엔터티
  3. 사건 엔터티 : 비즈니스 프로세스를 실행하면서 생성되는 엔터티
+ 발생 시점에 따른 엔터티 종류
  1. 기본 엔터티 : 키 엔터티, 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티
  2. 중심 엔터티 : 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 것
  3. 행위 엔터티 : 2개 이상의 엔터티로부터 발생된다.



### 속성

#### 속성

속성이라는 것은 업무에서 필요한 정보인 엔터티가 가지는 항목이다.

속성은 더 이상 분리되지 않는 단위로, 업무에 필요한 데이터를 저장할 수 있다.

인스턴스의 구성요소이고, 의미적으로 더 이상 분해되지 않는다.

+ 엔터티
  + 속성
    + 데이터 저장

#### 속성의 특징과 종류

1. 특징 : 업무에서 관리되는 정보, 하나의 값만 가짐, 주 식별자에게 함수적으로 종속, 즉 기본키가 변경되면 속성의 값도 변경됨
2. 종류 
   + 분해 여부에 따른 속성의 종류
     1. 단일 속성 : 하나의 의미로 구성된 것
     2. 복합 속성 : 여러개의 의미가 있는 것, ex) 주소
     3. 다중값 속성 : 여러개의 값을 가질 수 있는 것. 다중값 속성은 엔터티로 분해된다.
   + 특성에 따른 속성의 종류
     1. 기본 속성 : 비즈니스 프로세스에서 도출되는 본래의 속성
     2. 설계 속성 : 데이터 모델링 과정에서 발생되는 속성, 유일한 값 부여
     3. 파생 속성 : 다른 속성에 의해서 만들어지는 속성
3. 도메인 : 속성이 가질 수 있는 값의 범위.



### 관계

#### 관계 (Relationship)

관계는 에터티 간의 관련성을 의미하며 존재관계와 행위관계로 분류됨.

존재관계는 두 개의 엔터티가 존재 여부의 관계가 있는 것이고, 행위 관계는 두 개의 엔터티가 어떤 행위에 의한 관련성이 있는 것.

#### 관계의 종류

1. 존재 관계 : 엔터티간의 상태를 의미. 고객이 은행에 회원가입을 하면, 관리점이 할당되고, 그 할당괸 관리점에서 고객 관리
2. 행위 관계 : 어떤 행위가 엔터티간에 있는 것,

#### 관계 차수

관계 차수는 두 개의 엔터티 간에 관계에 참여하는 수를 의미.

(관계 차수에 관한 그림은 책 74p 참고)

1. 1대1 관계 

   + 완전 1대1 관계 : 하나의 엔터티에 관계되는 엔터티의 관계가 하나인 경우로 반드시 존재
   + 선택적 1대1 관계 : 하나의 엔터티에 관계되는 엔터티의 관계가 하나이거나 없을수도 있음.

2. 1대N 관계 : 엔터티의 행이 하나 있을 때 다른 엔터티의 값이 여러 개 있는 관계. ex) 고객은 계좌를 여러개를 가질 수 있다.

3. M대N 관계 : 두 개의 엔터티가 서로 여러개의 관계를 가지고 있는 것. 1대N, N대1 로 해소해야 한다.

4. 필수적 관계와 선택적 관계.

   필수적 관계는 `|`로 표현되고, 반드시 하나가 있어야 하는 관계이다.

    선택적 관계는 `O` 로 표현되고, 없을수도 있는 관계이다.

   `고객 -|-------O- 계좌`

   `고객`은 `계좌`가 있어도 되고 없어도 되기 때문에 `계좌`는 `O` 로 표현한다. 하지만 `계좌`는 무조건 `고객`이 있어야한다. 따라서 `고객`은 `|` 로 표현한다.

   필수적으로 있어야 하는 쪽에 `|` 를 쓰고 선택적으로 있어야 하는 쪽에 `O` 를 쓴다.

#### 식별 관계와 비식별 관계

1. 식별 관계 

   강한 개체는 다른 엔터티에게 의존하지 않고 독립적으로 존재한다. 강한 개체가 다른 엔터티와 관계를 가질 떄 다른 엔터티에게 기본키를 공유한다. 강한 개체는 식별 관계로 표현된다. 식별관계란 강한 개체의 기본키를 다른 엔터티의 기본키 하나로 공유하는 것이다. 강한 개체의 기본키 값이 변경되면 식별 관계에 있는 엔터티의 값도 변경된다. 실선으로 표현한다.

   `고객 -|------------O- 계좌` 와 같은 관계가 있을 때, 강한 개체는 `고객` 이다. `고객` 은 계좌 없이도 독립적인 존재가 가능하다.

   `고객`의 기본키를 `계좌`가 공유할 때, `고객`의 기본키가 변경되면 `계좌`의 기본키도 변경된다.

2. 비식별 관계

   비식별 관계는 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것이다.

   비식별 관계는점선으로 표현한다.

   `부서 -|- - - - - - - O - 사원`

3. 강한개체와 약한개체

   강한 개체는 누구에게도 지배되지 않고 독립적인 개체

   약한 개체는 개체의 존재가 다른 개체의 존재에 달려있는 개체이다.

#### 엔터티 식별자

식별자는 엔터티를 대표할 수 있는 유일성을 만족하는 속성.

1. 주 식별자

   주 식별자는 다음과 같은 속성을 가져야 한다.

   + 최소성
   + 대표성 : 엔터티를 대표할 수 있어야 하는 것
   + 유일성 : 유일하게 인스턴스를 식별
   + 불변성 : 자주 변경되지 않아야함

2. 키의 종류

   + 기본키 : 엔터티를 대표하는 키
   + 후보키 : 유일성과 최소성을 만족하는 키
   + 슈퍼키 : 유일성은 만족하지만 최소성을 만족하지 않는 키
   + 대체키 : 여러개의 후보키 중에서 기본키를 선정하고 남은 키
   + 외래키 : 하나 혹은 다수의 다른 테이블의 기본 키 필드를 가리키는 것으로 참조 무결성을 확인하기 위해서 사용되는 키. 허용된 값만 데이터베이스에 저장하기 위해서 사용

3. 식별자의 종류

   1. 식별자의 대표성 에 따른 종류 
      + 주 식별자 : 엔터티를 대표할 수 있는 식별자이며 다른 엔터티와 참조관계로 연결될 수 있다.
      + 보조 식별자 : 유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자
   2. 생성 여부에 따른 식별자 종류
      + 내부 식별자 : 엔터티 내부에서 스스로 생성되는 식별자. (주문번호, 종목코드 등등)
      + 외부 식별자 : 다른 엔터티와의 관계로 인하여 만들어지는 식별자
   3. 속성의 수에 따른 종류
      + 단일 식별자 : 하나의 속성으로 구성됨
      + 복합 식별자 : 두 개 이상의 속성으로 구성됨
   4. 대체 여부에 따른 종류
      + 본질 식별자 : 비즈니스 프로세스에서 만들어지는 식별자
      + 인조 식별자 : 인위적으로 만들어지는 식별자. 후보 식별자 중에서 주식별자로 선정할 것이 없거나 주 식별자가 너무 많은 칼럼으로 되어 있는 경우에 사용한다. 순서번호를 사용해서 식별자 생성.



## 데이터 모델과 성능

### 정규화

#### 정규화

정규화는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법. 데이터를 분해하는 과정.

데이터 중복을 제거하고 모델의 독립성을 확보하기 위한 방법.

비즈니스에 변화가 발생하여도 데이터 모델의 변경 최소화 가능

제1정규화부터 제5 정규화까지 있으나, 실질적으로는 제 3 정규화까지만 수행.

정규화된 모델은 테이블이 분해된다. 테이블이 분해되면 `join` 을 수행하여 합집합으로 만들 수 있다.

#### 함수적 종속성

1. 제 1 정규화

   + 정규화는 __함수적 종속성__을 근거로 한다. 함수적 종속성이란 `X->Y` 이면 `y`는  `x` 에 함수적으로 종속된다고 말한다.
   + `x` 가 변화하면 `y` 도 변화할 경우, 함수적으로 종속된다고 말한다.
   + `x` 는 기본키가 된다. 기본키가 바뀌면 다른 속성 `y` 가 바뀐다.
   + 제 1 정규화는 기본 키를 잡는것이다. 기본키를 바탕으로 다른 속성들을 함수적으로 종속시킨다.

2. 제 2 정규화

   + 기본키가 1개일 경우 제 2 정규화는 생략한다.

   + 기본키가 2개 이상일 경우 제 2 정규화를 시행한다. 제 2 정규화는 __부분 함수 종속성__을 제거한다.

   + 부분함수 종속성 : 기본키가 2개 이상인 경우, 하나의 기본 키가 바뀌었을 때 (`x`) 다른 속성이 바뀌는 것이 있다면(`y`) 그것을 부분 함수 종속성이라 말한다. 부분함수 종속성이 발생하면 분해를 해야한다.

     예를 들어 `X` 가 계좌번호, 회원ID 이고, Y가 계좌명, 예수금, 이름, 관리점일 때, 회원ID가 바뀌면 이름이 바뀐다. 따라서

     `x(계좌번호, 회원ID) -> y(계좌명, 예수금, 관리점)` & `x(회원ID) -> y(이름)` 

     위와 같이 새로운 테이블을 만들어낸다.

3. 제 3 정규화

   + 제 3 정규화는 __이행 함수 종속성__을 제거한다. 기본키를 제외하고 칼럼간에 종속성이 발생하는 것이다.

   + 제 3 정규화는 제1, 2 정규화를 수행한 다음 해야한다.

   + `y` 칼럼간의 종속성이 발생하면 이를 해소해주어야한다.

     예를들어 `x(계좌번호, 회원ID) -> y(계좌명, 예수금, 관리점코드, 관리점)` 일때, 관리점 코드와 관리점 사이에는 종속성이 발생한다. 관리점 코드가 바뀌면 관리점이 바뀐다. 따라서

     `x(계좌번호, 회원ID) -> y(계좌명, 예수금, 관리점코드)` & `x(관리점 코드) -> y(관리점)` 

     위와같이 새로운 테이블을 만들어낸다.

#### 정규화 정리

1. 한 개의 속성의 기본키로는 유일성을 만족할 수 없을 경우 2개의 조합으로 유일성이 만족되는지 확인한다. 이렇게 기본 키를 찾는 과정이 제 1 정규화이다.

2. 기본키가 2개 이상일 경우 제 2 정규화 대상이다. 하나의 기본키에서 중복이 발생하는지 확인해야한다.

   즉, 회원ID 와 이름은 같은데 계좌번호,계좌명,예수금,관리점이 다른 경우가 발생할 수 있다. 이 경우 회원ID와 이름을 분해하여 새로운 테이블을 생성한다.

   다른 예로, 제품번호(기본키), 제품명, 재고수량이 같지만, 주문번호(기본키)가 다른 제품이 존재할 수 있다. 이 경우 제품번호를 기본키로하고 제품명, 재고수량을 칼럼으로 가지는 새로운 테이블을 생성한다.

   이렇게 기본키가 2개 이상인 경우 중복을 가지는 칼럼이 존재하게될 수 있는데, 이걸 제거하는 것이 제 2 정규화이다.



### 정규화와 성능

#### 정규화의 문제점

정규화는 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높인다. 하지만 정규화는 데이터 조회시에 `join` 을 유발하기 떄문에 cpu와 메모리를 많이 사용한다. 이때 중첩된 루프를 사용하는데, 성능저하가 발생하게 된다. 이를 해결하기 위해 반 정규화가 사용된다.

하지만 성능 향상을 위한 반 정규화는 데이터를 중복시키기 때문에 또 다른 문제가 발생할 수도 있다. 데이터의 칼럼을 증가시키면 `join`이 적어지지만, 블록 사이즈를 넘어설 경우 여러개의 블록을 읽게 되고 이는 성능저하로 이어진다.

정규화는 입출력 데이터의 양을 줄여서 성능을 향상시키는 것이 낫다.



### 반정규화

#### 반정규화

데이터베이스의 성능 향상을 위하여 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다. 

반정규화는 조회 속도를 향상하지만 데이터 모델의 유연성은 낮아진다.

#### 반정규화를 수행하는 경우

1. 정규화에 충실하면 종속성, 활용성은 향상되나 수행 속도가 느려지는 경우
2. 다량의 범위를 자주 처리해야 하는 경우
3. 특정 범위의 데이터만 자주 처리하는 경우
4. 요약/집계 정보가 자주 요구되는 경우

+ 절차
  1. 대상 조사 및 검토
  2. 다른 방법 검토 : 반정규화를 수행하기 전 다른 방법이 있는지 검토
  3. 반정규화 수행

#### 반정규화 기법

1. 계산된 칼럼 추가.

   배치 프로그램으로 총액, 평균과 같은 정보를 미리 계산하고 그 결과를 특정 칼럼에 추가

2. 테이블 수직 분할

   하나의 테이블을 두 개 이상의 테이블로 분할, 칼럼을 분할하여 새로운 테이블 생성

   `key - c1, c2, c3, c4` -> `key - c1, c2` & `key - c3, c4`

3. 테이블 수평 분할

   하나의 테이블에 있는 값을 기준으로 테이블을 분할한다.

   ex) 2020~2000 년도까지의 데이터를 가진 테이블 1개, 1999~1980 년도까지의 데이터를 가진 테이블 1개, 총 2개의 테이블로 나눔

   ​	기존 테이블은 2020~1980 데이터를 가졌지만 2개로 나눔

   + 파티션 기법

     데이터베이스의 파티션을 사용하여 테이블을 분할할 수 있다. 파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러개의 데이터 파일에 분산되어서 저장된다.

     1. range partition : 데이터 값의 범위를 기준으로 파티셔닝
     2. list partition : 특정 값을 지정하여 파티셔닝
     3. hash partition : 해시 함수를 적용하여 파티셔닝
     4. composition partition : 범위와 해시를 복합적으로 사용하여 파티셔닝

     장점 : 성능향상, 각 테이블의 독립적 백업 및 복구

4. 테이블 병합

   1대1 관계의 테이블을 하나의 테이블로 병합하여 성능 향상.

   1대N 관계의 테이블을 하나의 테이블로 병합하여 성능 향상도 가능하지만 많은양의 데이터 중복이 발생할 수 있다.

   + 슈퍼타입과 서브타입

     데이터를 통합하여 성능 향상이 가능하다.

     ex) 고객 엔터티의 개인고객과 법인고객. 고객 엔터티가 슈퍼타입이고 개인고객과 법인고객이 서브타입. 배타적 관계는 개인고객이거나 법인고객인 경우, 포괄적 관계는 개인고객일 수도 있고 법인 고객일 수도 있는것.

     1. OneToOne 타입 : 슈퍼타입과 서브타입을 개별 테이블로 도출, 테이블이 많아 조인이 많고 관리가 어려움
     2. Plus 타입 : 슈퍼타입과 서브타입 테이블로 도출, 조인이 발생하고 관리가 어려움
     3. Single 타입 : 슈퍼타입과 서브타입을 하나의 테이블로 도출, 조인성능이 좋고 편리하지만 입출력 성능이 나쁨.



### 분산 데이터베이스

#### 분산데이터베이스

중앙 집중형 데이터베이스 : 데이터베이스 시스템 구축 시에 한 대의 물리적 시스템에 데이터 베이스 관리 시스템을 설치하고 여러명의 사용자가 데이터베이스 관리 시스템에 접속하여 사용하는 구조

분산데이터베이스 : 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여주고 분산된 작업 처리 수행

+ 분산데이터베이스 투명성

  투명성은 중요한 요소. 분산DB 는 투명성을 제공해야한다.

  1. 분할 투명성 : 고객은 여러 시스템에 저장되어있는걸 느낄 필요가 없다
  2. 위치 투명성 : 고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없다
  3. 지역 사상 투명성 : 각 지역 시스템 이름과 무관한 이름이 사용 가능
  4. 중복 투명성 : 데이터베이스 객체가 여러 시스템에 중복되어 존재해도 고객과는 무관하게 일관성이 유지됨
  5. 장애 투명성 : 각 지역의 시스템이나 통신망의 이상이 생겨도 데이터의 무결성 보장
  6. 병행 투명성 : 여러 고객이 동시에 트랜잭션을 수행해도 결과에 이상이 없어야함

#### 설계 방식

1. 상향식 설계 방식 : 지역 스키마 작성 후 전역 스키마를 작성하여 분산 데이터베이스 구축

   지역별로 데이터베이스 구축한 후 전역 스키마로 통합

2. 하향식 설계 방식 : 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스 구축

   기업 전체의 전사 데이터 모델을 수렴하여 전역 스키마를 생성하여 각 지역별로 스키마 생성

+ 장점 
  1. 신뢰성과 가용성이 높다
  2. 빠른 응답이 가능하다
  3. 용량 확장이 쉽다
+ 단점
  1. 관리와 통제가 어렵다
  2. 보안관리가 어렵다
  3. 데이터 무결성 관리가 어렵다
  4. 데이터베이스 설계가 복잡하다.



# SQL 기본 및 활용

## SQL 기본

### 관계형 데이터베이스

#### 관계형 데이터베이스

1. 데이터베이스와 데이터베이스 관리 시스템의 차이점
   + 데이터베이스는 데이터를 어떠한 형태의 자료구조로 사용하느냐에 따라서 나누어진다.
   + 종류 
     1. 계층형 : 트리 형태의 자료구조에 데이터를 저장하고 관리. 1대N관계
     2. 네트워크 : 오너,멤버 형태로 데이터 저장. 1대N과 M대N 표현 가능
     3. 관계형 : 릴레이션에 데이터를 저장하고 관리. 집합연산과 관계연산 가능
   + 데이터베이스 관리 시스템(DBMS)는 데이터베이스를 관리하기 위한 소프트웨어
   + Oracle, MS-SQL, MySQL등이 있음
2. 관계형 데이터베이스의 집합연산과 관계연산
   + 집합연산
     1. 합집합 : 두 개의 릴레이션을 하나로 합하는 것, 중복행은 한번만 조회
     2. 차집합 : 본래 릴레이션에는 존재하고 다른 릴레이션에는 존재하지 않는 것을 조회
     3. 교집합 : 두 릴레이션의 공통된 행을 조회
     4. 곱집합 : 각 릴레이션에 존재하는 모든 데이터를 조합하여 연산
   + 관계연산
     1. 선택 연산 : 조건에 맞는 행만 조회
     2. 투영연산 : 릴레이션에서 조건에맞는 속성만을 조회
     3. 결합연산 : 공통된 속성을 사용해서 새로운 릴레이션 생성
     4. 나누기연산 : 기존 릴레이션에서 나누는 릴레이션이 가진 속성과 동일한 값을 가지는 행을 추출하고 나누는 릴레이션의 속성을 삭제한 뒤 중복행 제거

#### 테이블 구조

관계형 데이터베이스는 릴레이션에 데이터를 저장, 릴레이션을 사용해 집합 연산 및 관계연산 지원. -> 다양한 형태로 데이터 조회

릴레이션은 최종적으로 테이블로 만들어짐

+ 테이블 구성요소
  1. 튜플 : 테이블의 행
  2. 속성 : 테이블의 열
  3. 기본키 : 하나의 테이블에서 유일성, 최소성, `Not Null` 을 만족하는 열.
  4. 외래키 : 다른 테이블의 기본키를 참조하는 칼럼. 결합연산(`join`)을 위해서 사용



### SQL 종류

#### SQL

+ `sql` 은 관계형 데이터베이스에 대해서 데이터의 구조정의, 조작, 제어를 할 수 있는 절차형 언어.
+ ANIS/ISO 표준을 준수한다. (책 110페이지 참조)

#### SQL 종류

1. 종류

   + DDL(Data Definition Language) : 구조를 정의하는 언어. `CREATE` `ALTER` `DROP` `RENAME`
   + DML(Data Manipulate Language) : 데이터를 입력 수정 삭제 조회. `INSERT` `UPDATE` `DELETE` `SELECT` 
   + DCL(Data Control Language) : 데이터베이스 사용자에게 권한을 부여하거나 회수. `GRANT` `REVOKE` `TRUNCATE`
   + TCL(Transation Control Language) : 트랜잭션을 제어하는 명령어. `COMMIT` `ROLLBACK` `SAVEPOINT`

2. 트랜잭션

   트랜잭션은 데이터베이스의 작업을 처리하는 단위. 다음과 같은 특성을 가진다.

   + 원자성 : 연산의 전부가 실행되거나 전혀 실행되지 않아야한다. 처리가 완전히 끝나지 않으면 아예 실행하지 않은것과 동일
   + 일관성 : 데이터베이스의 상태가 트랜잭션 전후로 일관성이 유지되어야함. 모순되면안됨
   + 고립성 : 트랜잭션 실행중의 연산 중간결과는 다른 트랜잭션이 접근할 수 없음. 부분적인 실행결과 볼 수 없음
   + 영속성 : 트랜잭션이 실행을 완료하면 영구적인 보장이 되어야함.

#### SQL문의 실행 순서

SQL 문은 3단계를 걸쳐서 실행된다.

1. 파싱 : 문법을 확인하고 구문분석, 캐시에 저장
2. 실행 : 옵티마이저가 수립한 실행계획에 따라 실행
3. 인출 : 데이터를 읽어서 전송



### DDL - Data Definition Language

#### 테이블 생성

데이터베이스를 사용하기 위해서는 테이블을 먼저 생성해야한다.

+ 테이블 관리 SQL

  + `CREATE TABLE` : 새로운 테이블 생성. 기본키, 외래키, 제약사항 등 설정 가능
  + `ALTER TABLE` : 생성된 테이블 변경. 칼럼의 추가,변경,삭제 가능. 기본키, 외래키 설정가능
  + `DROP TABLE` : 테이블 삭제. 구조와 저장된 데이터 모두 삭제.

+ 기본적인 테이블 생성.

  ```sql
  CREATE TABLE 테이블이름(
  	칼럼1 number(10) PRIMARY KEY,
      칼럼2 varchar2(20),
      칼럼3 char(6)
  );
  ```

  1. `CREATE TABLE` 다음에 테이블 이름을 정함으로서 테이블을 생성한다.
  2. 괄호 안에 칼럼을 설정할 수 있다. `칼럼이름 데이터타임` 과 같이 선언한다. 
  3. `PRIMARY KEY` 는 기본키 설정이다.

+ 제약조건 사용

  기본키, 외래키, 기본값, `NOT NULL` 등은 테이블을 생성할 때 지정할 수 있다.

  ```sql
  CREATE TALBE EMP(
  	EMPNO number(10),
      SAL varchar2(20) default 0,
      DEPTNO number(10) NOT NULL,
      CREATEDATE date default sysdate,
      constraint emppk PRIMARY KEY(EMPNO)    
  );
  ```

  1. `constraint` 명령어를 사용하여 기본키와 기본키의 이름을 지정한다. 두 개의 기본키를 지정하고자 하면 `constraint emppk PRIMARY KEY(EMPNO,SAL)` 과 같은 형식으로 지정하면 된다.
  2. `default` 명령어로 기본값을 입력할 수 있다. `sysdate` 는 시스템상 시간을 의미한다.
  3. `NOT NULL` 명령어는 빈 값을 허용하지 않는다는 뜻이다.

+ CASCADE

  테이블 생성 시 참조관계(기본키와 외래키 관계)가 있을 경우 참조되는 데이터를 자동으로 반영한다.

  테이블 생성시 다음과 같은 명령어를 사용한다

  ```sql
  CREATE TALBE EMP(
  	EMPNO number(10),
      SAL varchar2(20) default 0,
      constraint emppk PRIMARY KEY(EMPNO)  # 기본키 설정
      constraint deptk FOREIGN KEY(DEPTNO) # 외래키 설정, CASCADE 옵션
      	references DEPT(DEPTNO)
      	ON DELETE CASCADE
  );
  ```

  `ON DELETE CASCADE` 옵션을 설정하여 참조무결성을 준수할 수 있다. `EMP` 테이블에서 데이터가 삭제되면, 참조하고있는 `DEPT` 테이블의 데이터가 자동으로 삭제되는 옵션이다.

#### 테이블 변경

기본적으로 `ALTER TABLE 이름 ~` 과 같은 명령어로 구문을 사용할 수 있다.

1. 테이블명 변경

   `RENAME` 명령어를 통해 새로은 이름으로 변경할 수 있다.

   ```sql
   ALTER TABLE EMP
   	RENAME TO NEW_EMP;
   ```

2. 칼럼 추가

   `ADD` 명령어로 칼럼을 추가할 수 있다.

   ```sql
   ALTER TALBE EMP
   	ADD(age number(2) default 1);
   ```

3. 칼럼 변경

   `MODFIY` 명령어로 칼럼을 변경할 수 있다. 이때, 데이터 타입을 변경하거나 길이를 변경할 수 있다. 제약조건의 설정도 가능하다.

   만약에 변경할 테이블의 기존 데이터의 데이터타입과 변경하는 데이터 타입이 다른 경우 에러가 발생한다.

   ```sql
   ALTER TABLE EMP
   	MODIFY(ename varchar2(20) not null);
   ```

4. 칼럼 삭제

   `DROP COLUMN` 으로 삭제한다.

   ```sql
   ALTER TABLE EMP
   	DROP COLUMN age;
   ```

5. 칼럼명 변경

   ```sql
   ALTER TABLE EMP
   	RENAME COLUMN enmae to new_ename
   ```

#### 테이블 삭제

테이블 삭제는 `DROP TABLE 테이블이름` 을 사용해 삭제한다.

테이블 삭제시에도 `CASCADE` 옵션을 사용 가능하다. `DROP TABLE EMP CASCADE CONSTRAINT` 명령어로 해당 테이블을 참조한 관련 제약사항을 모두 삭제한다.

#### 뷰 생성과 삭제

뷰는 테이블로부터 유도된 가상 테이블이다. 실제 데이터는 가지고 있지 않고 테이블을 참조해서 원하는 칼럼만을 조회한다. 딕셔너리에 SQL문 형태로 저장되며 실행시 참조된다.

뷰를 생성할 때 `CREATE VIEW` 를 사용한다. 참조할 테이블은 `SELECT` 로 지정한다.

```SQL
CREATE VIEW T AS
	SELECT * FROM EMP;
```

뷰의 조회는 일반 테이블과 같다.

```SQL
SELECT * FROM T;
```

뷰의 삭제는 `DROP VIEW 뷰이름` 구문을 사용한다. 참조했던 테이블은 삭제되지 않는다.

+ 장점
  1. 특정 칼럼만 조회할 수 있어 보안성이 높다
  2. 데이터 관리가 간단하다
  3. `SELECT` 문이 간결해진다.
  4. 하나의 테이블에 여러개의 뷰를 생성할 수 있다.
+ 단점
  1. 독자적인 인덱스를 만들 수 없다.
  2. 수정 삭제 연산이 제약된다.
  3. 데이터 구조를 변경할 수 없다.



### DML - Data Manipulate Language

#### INSERT

테이블에 데이터를 입력하는 명령어다.

`INSERT INTO 테이블이름(칼럼명...) VALUES(입력할값...)` 과 같은 형태로 사용한다.

문자열 입력시에는 작은따옴표를 사용한다. 모든 칼럼에 대해 데이터를 입력할떄는 칼럼명을 생략할 수 있다. 

최종적으로 `COMMIT` 을 실행해야 저장되지만, `AUTO COMMIT` 일 경우 자동으로 저장된다.

+ SELECT 로 입력

  데이터를 조회해서 특정 테이블에 바로 삽입할 수 있다. 단 입력되는 테이블은 사전에 생성되어있어야 한다.

  ```SQL
  INSERT INTO A     # 테이블 A를 미리 만들어둬야한다.
  	SELECT * FROM B;
  ```

+ NOLOGGIN 사용

  데이터베이스에 데이터를 입력하면 로그파일에 그 정보를 기록한다. `NOLOGGIN` 옵션은 로그파일의 기록을 최소화시킨다.

  ```SQL
  INSERT INTO A NOLOGGIN;
  ```

#### UPDATE

입력된 데이터의 값을 수정할 수 있다. 해당되는 행을 수정한다.

```SQL
UPDATE A
	SET ANAME = '조조'
	WHERE ANUM = 100;
```

테이블 A의 `ANAME` 이라는 칼럼의 값을 `조조` 로 변경하는데, `ANUM = 100` 인 행만 적용한다.

만약 조건절을 붙이지 않으면 모든 데이터가 변경된다.

#### DELETE

원하는 조건을 검색해서 해당되는 행을 삭제한다. 만약 조건이 없으면 모든 데이터를 삭제한다.

```SQL
DELETE FROM A
	WHERE ANUM = 100;
```

`TRUNCATE` 옵션을 사용해서 용량을 초기화할 수 있다. `DELETE` 문을 사용해 데이터를 지운다 해도 용량은 감소하지 않는다.

`TRUNCATE DELETE FROM A` 구문을 사용하면 A테이블의 모든 데이터를 삭제함과 동시에 용량도 초기화한다.

#### SELECT


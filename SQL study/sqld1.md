# 데이터 모델링의 이해

## 데이터 모델링

### 데이터 모델링의 이해

#### 데이터 모델링

1. 현실 세계를 데이터 베이스로 표현하기 위해 추상화
2. 고객의 업무 프로세스를 이해해야함
3. 모델링 표기법을 사용해 모델링
4. 복잡하지 않게 모델링
5. 분석, 설계하면서 더 상세해짐
6. 비즈니스 프로세스를 이해하고  규칙을 정의하여 데이터모델로 표현

#### 데이터 모델링의 특징

추상화 : 공통적인 특징을 찾고 간략하게 표현

단순화 : 누구나 이해할 수 있게 표현

명확함 : 의미적 해석이 모호하지 않고 명확하게 해석되어야함

#### 데이터 모델링 단계

1. 개념적 모델링

   복잡하게 표현하지 않고 중요한 부분을 위주로 모델링, 기술적인 용어는 가급적 사용 안함.

   엔터티와 속성 도출, 개념적 ERD 작성

   추상화 수준이 가장 높다.

2. 논리적 모델링

   개념적 모델링을 논리적 모델링으로 변환, 식별자 도출, 릴레이션 정의, 정규화수행

   재사용성을 높인다

3. 물리적 모델링

   실제로 데이터베이스 구축. 테이블, 인덱스, 함수 등 생성

   성능, 보안, 가용성 등을 고려하여 데이터베이스 구축

+ 데이터 모델링 관점
  1. 데이터 : 비즈니스 프로세스에서 사용되는 데이터를 의미
  2. 프로세스 : 비즈니스 프로세스에서 수행하는 작업을 의미
  3. 데이터와 프로세스 : 프로세스와 데이터 간의 관계를 의미

#### ERD

+ ERD 작성절차

  1. 엔터티를 도출하고 그린다
  2. 엔터티를 배치한다
  3. 엔터티 간의 관계를 설정한다
  4. 관계명을 서술한다. 엔터티 간의 어떤 행위나 존재가 있는지 표현한다.
  5. 관계 참여도를 표현한다. 관계참여도는 한 개의 엔터티와 다른 엔터티 간의 참여하는 관계 수를 의미한다.
  6. 관계의 필수여부를 표현한다.

+ 고려사항

  중요한 엔터티를 가급적 왼쪽 상단에 배치한다.

  ERD는 이해가 쉬워야하고 복잡하지 않아야한다.

#### 데이터 모델링 고려사항

1. 데이터 모델의 독립성 : 정규화를 통해 데이터 중복 제가
2. 고객 요구사항의 표현 
3. 데이터 품질 확보



### 3층 스키마

#### 3층 스키마

사용자, 설계자, 개발자가 데이터베이스를 보는 관점에 따라 데이터베이스를 기술하고 이들간의 관꼐를 정의한 ANSI표준

3층 스키마는 데이터베이스의 독립성을 확보하기 위한 방법이다. 독립성을 확보하면 데이터 복잡도 감소, 데이터 중복 제거, 사용자 요구사항 변경에 따른 대응력 향상, 관리 및 유지보수 비용 절감

3단계 계층으로 분리, 각 계층을 뷰`View` 라고 함.

+ 논리적 독립성 : 개념 스키마가 변경되더라도 외부 스키마가 영향을 받지 않는 것
+ 물리적 독립성 : 내부 스키마가 변경되더라도 개념 스키마가 영향을 받지 않는 것

#### 3층 스키마 구조

외부단계 -> 개념단계 -> 내부단계

+ 외부 스키마 : 사용자 관점, 응용 프로그램이 접근하는 데이터베이스 정의, 사용자 관점에서 업무상 관련이 있는 데이터 접근.
+ 개념 스키마 : 설계자 관점, 사용자 전체 집단의 데이터베이스 구조. 전체 데이터베이스 내의 규칙과 구조를 표현, 통합 데이터베이스구조
+ 내부 스키마 : 개발자 관점, 데이터베이스의 물리적 저장 구조. 데이터저장구조, 레코드구조, 필드정의, 인덱스 등등의미.



### 엔터티

#### 엔터티

업무에서 관리해야 하는 데이터집합을 의미. 저장되고 관리되어야 하는 데이터.

엔터티는 개념, 사건, 장소등의 명사.

#### 엔터티 도출

고객의 비즈니스 프로세스에서 관리되어야 하는 정보를 추출.

#### 엔터티 특징

1. 식별자 : 엔터티는 유일한 식별자가 있어야함
2. 인스턴스 집합 : 2개 이상의 인스턴스가 있어야함
3. 속성 : 반드시 속성을 가지고 있음
4. 관계 : 다른 엔터티와 최소 한 개 이상의 관계를 가져야함
5. 업무 : 업무에서 관리되어야 하는 집합.

+ 릴레이션과 테이블, 인스턴스

  릴레이션과 테이블은 같은의미, 릴레이션에 기본키 및 제약조건을 설정하면 테이블.

  단, 릴레이션쉽은 릴레이션간의 관계를 의미

  인스턴스는 릴레이션이 가질 수 있는 값을 의미.

#### 엔터티 종류

+ 유형과 무형에 따른 엔터티 종류
  1. 유형 엔터티 : 업무에서 도출되어 지속적으로 사용되는 엔터티
  2. 개념 엔터티 : 물리적 형태가 없음. 개념적으로 사용되는 엔터티
  3. 사건 엔터티 : 비즈니스 프로세스를 실행하면서 생성되는 엔터티
+ 발생 시점에 따른 엔터티 종류
  1. 기본 엔터티 : 키 엔터티, 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티
  2. 중심 엔터티 : 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 것
  3. 행위 엔터티 : 2개 이상의 엔터티로부터 발생된다.



### 속성

#### 속성

속성이라는 것은 업무에서 필요한 정보인 엔터티가 가지는 항목이다.

속성은 더 이상 분리되지 않는 단위로, 업무에 필요한 데이터를 저장할 수 있다.

인스턴스의 구성요소이고, 의미적으로 더 이상 분해되지 않는다.

+ 엔터티
  + 속성
    + 데이터 저장

#### 속성의 특징과 종류

1. 특징 : 업무에서 관리되는 정보, 하나의 값만 가짐, 주 식별자에게 함수적으로 종속, 즉 기본키가 변경되면 속성의 값도 변경됨
2. 종류 
   + 분해 여부에 따른 속성의 종류
     1. 단일 속성 : 하나의 의미로 구성된 것
     2. 복합 속성 : 여러개의 의미가 있는 것, ex) 주소
     3. 다중값 속성 : 여러개의 값을 가질 수 있는 것. 다중값 속성은 엔터티로 분해된다.
   + 특성에 따른 속성의 종류
     1. 기본 속성 : 비즈니스 프로세스에서 도출되는 본래의 속성
     2. 설계 속성 : 데이터 모델링 과정에서 발생되는 속성, 유일한 값 부여
     3. 파생 속성 : 다른 속성에 의해서 만들어지는 속성
3. 도메인 : 속성이 가질 수 있는 값의 범위.



### 관계

#### 관계 (Relationship)

관계는 에터티 간의 관련성을 의미하며 존재관계와 행위관계로 분류됨.

존재관계는 두 개의 엔터티가 존재 여부의 관계가 있는 것이고, 행위 관계는 두 개의 엔터티가 어떤 행위에 의한 관련성이 있는 것.

#### 관계의 종류

1. 존재 관계 : 엔터티간의 상태를 의미. 고객이 은행에 회원가입을 하면, 관리점이 할당되고, 그 할당괸 관리점에서 고객 관리
2. 행위 관계 : 어떤 행위가 엔터티간에 있는 것,

#### 관계 차수

관계 차수는 두 개의 엔터티 간에 관계에 참여하는 수를 의미.

(관계 차수에 관한 그림은 책 74p 참고)

1. 1대1 관계 

   + 완전 1대1 관계 : 하나의 엔터티에 관계되는 엔터티의 관계가 하나인 경우로 반드시 존재
   + 선택적 1대1 관계 : 하나의 엔터티에 관계되는 엔터티의 관계가 하나이거나 없을수도 있음.

2. 1대N 관계 : 엔터티의 행이 하나 있을 때 다른 엔터티의 값이 여러 개 있는 관계. ex) 고객은 계좌를 여러개를 가질 수 있다.

3. M대N 관계 : 두 개의 엔터티가 서로 여러개의 관계를 가지고 있는 것. 1대N, N대1 로 해소해야 한다.

4. 필수적 관계와 선택적 관계.

   필수적 관계는 `|`로 표현되고, 반드시 하나가 있어야 하는 관계이다.

    선택적 관계는 `O` 로 표현되고, 없을수도 있는 관계이다.

   `고객 -|-------O- 계좌`

   `고객`은 `계좌`가 있어도 되고 없어도 되기 때문에 `계좌`는 `O` 로 표현한다. 하지만 `계좌`는 무조건 `고객`이 있어야한다. 따라서 `고객`은 `|` 로 표현한다.

   필수적으로 있어야 하는 쪽에 `|` 를 쓰고 선택적으로 있어야 하는 쪽에 `O` 를 쓴다.

#### 식별 관계와 비식별 관계

1. 식별 관계 

   강한 개체는 다른 엔터티에게 의존하지 않고 독립적으로 존재한다. 강한 개체가 다른 엔터티와 관계를 가질 떄 다른 엔터티에게 기본키를 공유한다. 강한 개체는 식별 관계로 표현된다. 식별관계란 강한 개체의 기본키를 다른 엔터티의 기본키 하나로 공유하는 것이다. 강한 개체의 기본키 값이 변경되면 식별 관계에 있는 엔터티의 값도 변경된다. 실선으로 표현한다.

   `고객 -|------------O- 계좌` 와 같은 관계가 있을 때, 강한 개체는 `고객` 이다. `고객` 은 계좌 없이도 독립적인 존재가 가능하다.

   `고객`의 기본키를 `계좌`가 공유할 때, `고객`의 기본키가 변경되면 `계좌`의 기본키도 변경된다.

2. 비식별 관계

   비식별 관계는 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 칼럼으로 관계를 가지는 것이다.

   비식별 관계는점선으로 표현한다.

   `부서 -|- - - - - - - O - 사원`

3. 강한개체와 약한개체

   강한 개체는 누구에게도 지배되지 않고 독립적인 개체

   약한 개체는 개체의 존재가 다른 개체의 존재에 달려있는 개체이다.

#### 엔터티 식별자

식별자는 엔터티를 대표할 수 있는 유일성을 만족하는 속성.

1. 주 식별자

   주 식별자는 다음과 같은 속성을 가져야 한다.

   + 최소성
   + 대표성 : 엔터티를 대표할 수 있어야 하는 것
   + 유일성 : 유일하게 인스턴스를 식별
   + 불변성 : 자주 변경되지 않아야함

2. 키의 종류

   + 기본키 : 엔터티를 대표하는 키
   + 후보키 : 유일성과 최소성을 만족하는 키
   + 슈퍼키 : 유일성은 만족하지만 최소성을 만족하지 않는 키
   + 대체키 : 여러개의 후보키 중에서 기본키를 선정하고 남은 키
   + 외래키 : 하나 혹은 다수의 다른 테이블의 기본 키 필드를 가리키는 것으로 참조 무결성을 확인하기 위해서 사용되는 키. 허용된 값만 데이터베이스에 저장하기 위해서 사용

3. 식별자의 종류

   1. 식별자의 대표성 에 따른 종류 
      + 주 식별자 : 엔터티를 대표할 수 있는 식별자이며 다른 엔터티와 참조관계로 연결될 수 있다.
      + 보조 식별자 : 유일성과 최소성은 만족하지만 대표성을 만족하지 못하는 식별자
   2. 생성 여부에 따른 식별자 종류
      + 내부 식별자 : 엔터티 내부에서 스스로 생성되는 식별자. (주문번호, 종목코드 등등)
      + 외부 식별자 : 다른 엔터티와의 관계로 인하여 만들어지는 식별자
   3. 속성의 수에 따른 종류
      + 단일 식별자 : 하나의 속성으로 구성됨
      + 복합 식별자 : 두 개 이상의 속성으로 구성됨
   4. 대체 여부에 따른 종류
      + 본질 식별자 : 비즈니스 프로세스에서 만들어지는 식별자
      + 인조 식별자 : 인위적으로 만들어지는 식별자. 후보 식별자 중에서 주식별자로 선정할 것이 없거나 주 식별자가 너무 많은 칼럼으로 되어 있는 경우에 사용한다. 순서번호를 사용해서 식별자 생성.



## 데이터 모델과 성능

### 정규화

#### 정규화

정규화는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법. 데이터를 분해하는 과정.

데이터 중복을 제거하고 모델의 독립성을 확보하기 위한 방법.

비즈니스에 변화가 발생하여도 데이터 모델의 변경 최소화 가능

제1정규화부터 제5 정규화까지 있으나, 실질적으로는 제 3 정규화까지만 수행.

정규화된 모델은 테이블이 분해된다. 테이블이 분해되면 `join` 을 수행하여 합집합으로 만들 수 있다.

#### 함수적 종속성

1. 제 1 정규화

   + 정규화는 __함수적 종속성__을 근거로 한다. 함수적 종속성이란 `X->Y` 이면 `y`는  `x` 에 함수적으로 종속된다고 말한다.
   + `x` 가 변화하면 `y` 도 변화할 경우, 함수적으로 종속된다고 말한다.
   + `x` 는 기본키가 된다. 기본키가 바뀌면 다른 속성 `y` 가 바뀐다.
   + 제 1 정규화는 기본 키를 잡는것이다. 기본키를 바탕으로 다른 속성들을 함수적으로 종속시킨다.

2. 제 2 정규화

   + 기본키가 1개일 경우 제 2 정규화는 생략한다.

   + 기본키가 2개 이상일 경우 제 2 정규화를 시행한다. 제 2 정규화는 __부분 함수 종속성__을 제거한다.

   + 부분함수 종속성 : 기본키가 2개 이상인 경우, 하나의 기본 키가 바뀌었을 때 (`x`) 다른 속성이 바뀌는 것이 있다면(`y`) 그것을 부분 함수 종속성이라 말한다. 부분함수 종속성이 발생하면 분해를 해야한다.

     예를 들어 `X` 가 계좌번호, 회원ID 이고, Y가 계좌명, 예수금, 이름, 관리점일 때, 회원ID가 바뀌면 이름이 바뀐다. 따라서

     `x(계좌번호, 회원ID) -> y(계좌명, 예수금, 관리점)` & `x(회원ID) -> y(이름)` 

     위와 같이 새로운 테이블을 만들어낸다.

3. 제 3 정규화

   + 제 3 정규화는 __이행 함수 종속성__을 제거한다. 기본키를 제외하고 칼럼간에 종속성이 발생하는 것이다.

   + 제 3 정규화는 제1, 2 정규화를 수행한 다음 해야한다.

   + `y` 칼럼간의 종속성이 발생하면 이를 해소해주어야한다.

     예를들어 `x(계좌번호, 회원ID) -> y(계좌명, 예수금, 관리점코드, 관리점)` 일때, 관리점 코드와 관리점 사이에는 종속성이 발생한다. 관리점 코드가 바뀌면 관리점이 바뀐다. 따라서

     `x(계좌번호, 회원ID) -> y(계좌명, 예수금, 관리점코드)` & `x(관리점 코드) -> y(관리점)` 

     위와같이 새로운 테이블을 만들어낸다.

#### 정규화 정리

1. 한 개의 속성의 기본키로는 유일성을 만족할 수 없을 경우 2개의 조합으로 유일성이 만족되는지 확인한다. 이렇게 기본 키를 찾는 과정이 제 1 정규화이다.

2. 기본키가 2개 이상일 경우 제 2 정규화 대상이다. 하나의 기본키에서 중복이 발생하는지 확인해야한다.

   즉, 회원ID 와 이름은 같은데 계좌번호,계좌명,예수금,관리점이 다른 경우가 발생할 수 있다. 이 경우 회원ID와 이름을 분해하여 새로운 테이블을 생성한다.

   다른 예로, 제품번호(기본키), 제품명, 재고수량이 같지만, 주문번호(기본키)가 다른 제품이 존재할 수 있다. 이 경우 제품번호를 기본키로하고 제품명, 재고수량을 칼럼으로 가지는 새로운 테이블을 생성한다.

   이렇게 기본키가 2개 이상인 경우 중복을 가지는 칼럼이 존재하게될 수 있는데, 이걸 제거하는 것이 제 2 정규화이다.



### 정규화와 성능

#### 정규화의 문제점

정규화는 테이블을 분해해서 데이터 중복을 제거하기 때문에 데이터 모델의 유연성을 높인다. 하지만 정규화는 데이터 조회시에 `join` 을 유발하기 떄문에 cpu와 메모리를 많이 사용한다. 이때 중첩된 루프를 사용하는데, 성능저하가 발생하게 된다. 이를 해결하기 위해 반 정규화가 사용된다.

하지만 성능 향상을 위한 반 정규화는 데이터를 중복시키기 때문에 또 다른 문제가 발생할 수도 있다. 데이터의 칼럼을 증가시키면 `join`이 적어지지만, 블록 사이즈를 넘어설 경우 여러개의 블록을 읽게 되고 이는 성능저하로 이어진다.

정규화는 입출력 데이터의 양을 줄여서 성능을 향상시키는 것이 낫다.



### 반정규화

#### 반정규화

데이터베이스의 성능 향상을 위하여 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능 향상 방법이다. 

반정규화는 조회 속도를 향상하지만 데이터 모델의 유연성은 낮아진다.

#### 반정규화를 수행하는 경우

1. 정규화에 충실하면 종속성, 활용성은 향상되나 수행 속도가 느려지는 경우
2. 다량의 범위를 자주 처리해야 하는 경우
3. 특정 범위의 데이터만 자주 처리하는 경우
4. 요약/집계 정보가 자주 요구되는 경우

+ 절차
  1. 대상 조사 및 검토
  2. 다른 방법 검토 : 반정규화를 수행하기 전 다른 방법이 있는지 검토
  3. 반정규화 수행

#### 반정규화 기법

1. 계산된 칼럼 추가.

   배치 프로그램으로 총액, 평균과 같은 정보를 미리 계산하고 그 결과를 특정 칼럼에 추가

2. 테이블 수직 분할

   하나의 테이블을 두 개 이상의 테이블로 분할, 칼럼을 분할하여 새로운 테이블 생성

   `key - c1, c2, c3, c4` -> `key - c1, c2` & `key - c3, c4`

3. 테이블 수평 분할

   하나의 테이블에 있는 값을 기준으로 테이블을 분할한다.

   ex) 2020~2000 년도까지의 데이터를 가진 테이블 1개, 1999~1980 년도까지의 데이터를 가진 테이블 1개, 총 2개의 테이블로 나눔

   ​	기존 테이블은 2020~1980 데이터를 가졌지만 2개로 나눔

   + 파티션 기법

     데이터베이스의 파티션을 사용하여 테이블을 분할할 수 있다. 파티션을 사용하면 논리적으로는 하나의 테이블이지만 여러개의 데이터 파일에 분산되어서 저장된다.

     1. range partition : 데이터 값의 범위를 기준으로 파티셔닝
     2. list partition : 특정 값을 지정하여 파티셔닝
     3. hash partition : 해시 함수를 적용하여 파티셔닝
     4. composition partition : 범위와 해시를 복합적으로 사용하여 파티셔닝

     장점 : 성능향상, 각 테이블의 독립적 백업 및 복구

4. 테이블 병합

   1대1 관계의 테이블을 하나의 테이블로 병합하여 성능 향상.

   1대N 관계의 테이블을 하나의 테이블로 병합하여 성능 향상도 가능하지만 많은양의 데이터 중복이 발생할 수 있다.

   + 슈퍼타입과 서브타입

     데이터를 통합하여 성능 향상이 가능하다.

     ex) 고객 엔터티의 개인고객과 법인고객. 고객 엔터티가 슈퍼타입이고 개인고객과 법인고객이 서브타입. 배타적 관계는 개인고객이거나 법인고객인 경우, 포괄적 관계는 개인고객일 수도 있고 법인 고객일 수도 있는것.

     1. OneToOne 타입 : 슈퍼타입과 서브타입을 개별 테이블로 도출, 테이블이 많아 조인이 많고 관리가 어려움
     2. Plus 타입 : 슈퍼타입과 서브타입 테이블로 도출, 조인이 발생하고 관리가 어려움
     3. Single 타입 : 슈퍼타입과 서브타입을 하나의 테이블로 도출, 조인성능이 좋고 편리하지만 입출력 성능이 나쁨.



### 분산 데이터베이스

#### 분산데이터베이스

중앙 집중형 데이터베이스 : 데이터베이스 시스템 구축 시에 한 대의 물리적 시스템에 데이터 베이스 관리 시스템을 설치하고 여러명의 사용자가 데이터베이스 관리 시스템에 접속하여 사용하는 구조

분산데이터베이스 : 물리적으로 떨어진 데이터베이스에 네트워크로 연결하여 단일 데이터베이스 이미지를 보여주고 분산된 작업 처리 수행

+ 분산데이터베이스 투명성

  투명성은 중요한 요소. 분산DB 는 투명성을 제공해야한다.

  1. 분할 투명성 : 고객은 여러 시스템에 저장되어있는걸 느낄 필요가 없다
  2. 위치 투명성 : 고객이 사용하려는 데이터의 저장 장소를 명시할 필요가 없다
  3. 지역 사상 투명성 : 각 지역 시스템 이름과 무관한 이름이 사용 가능
  4. 중복 투명성 : 데이터베이스 객체가 여러 시스템에 중복되어 존재해도 고객과는 무관하게 일관성이 유지됨
  5. 장애 투명성 : 각 지역의 시스템이나 통신망의 이상이 생겨도 데이터의 무결성 보장
  6. 병행 투명성 : 여러 고객이 동시에 트랜잭션을 수행해도 결과에 이상이 없어야함

#### 설계 방식

1. 상향식 설계 방식 : 지역 스키마 작성 후 전역 스키마를 작성하여 분산 데이터베이스 구축

   지역별로 데이터베이스 구축한 후 전역 스키마로 통합

2. 하향식 설계 방식 : 전역 스키마 작성 후 해당 지역 사상 스키마를 작성하여 분산 데이터베이스 구축

   기업 전체의 전사 데이터 모델을 수렴하여 전역 스키마를 생성하여 각 지역별로 스키마 생성

+ 장점 
  1. 신뢰성과 가용성이 높다
  2. 빠른 응답이 가능하다
  3. 용량 확장이 쉽다
+ 단점
  1. 관리와 통제가 어렵다
  2. 보안관리가 어렵다
  3. 데이터 무결성 관리가 어렵다
  4. 데이터베이스 설계가 복잡하다.
